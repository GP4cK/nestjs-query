"use strict";(self.webpackChunknestjs_query=self.webpackChunknestjs_query||[]).push([[6935],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>v});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),v=o,f=p["".concat(s,".").concat(v)]||p[v]||d[v]||a;return n?r.createElement(f,i(i({ref:t},c),{},{components:n})):r.createElement(f,i({ref:t},c))}));function v(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var u=2;u<a;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8215:(e,t,n)=>{n.d(t,{Z:()=>o});var r=n(7294);const o=function(e){var t=e.children,n=e.hidden,o=e.className;return r.createElement("div",{role:"tabpanel",hidden:n,className:o},t)}},6396:(e,t,n)=>{n.d(t,{Z:()=>p});var r=n(7462),o=n(7294),a=n(2389),i=n(9443);const l=function(){var e=(0,o.useContext)(i.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e};var s=n(3616),u=n(6010);const c="tabItem_vU9c";function d(e){var t,n,r,a=e.lazy,i=e.block,d=e.defaultValue,p=e.values,v=e.groupId,f=e.className,m=o.Children.map(e.children,(function(e){if((0,o.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),h=null!=p?p:m.map((function(e){var t=e.props;return{value:t.value,label:t.label}})),g=(0,s.lx)(h,(function(e,t){return e.value===t.value}));if(g.length>0)throw new Error('Docusaurus error: Duplicate values "'+g.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var y=null===d?d:null!=(t=null!=d?d:null==(n=m.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(r=m[0])?void 0:r.props.value;if(null!==y&&!h.some((function(e){return e.value===y})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+h.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var b=l(),x=b.tabGroupChoices,w=b.setTabGroupChoices,k=(0,o.useState)(y),O=k[0],j=k[1],C=[],N=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=v){var E=x[v];null!=E&&E!==O&&h.some((function(e){return e.value===E}))&&j(E)}var T=function(e){var t=e.currentTarget,n=C.indexOf(t),r=h[n].value;r!==O&&(N(t),j(r),null!=v&&w(v,r))},q=function(e){var t,n=null;switch(e.key){case"ArrowRight":var r=C.indexOf(e.currentTarget)+1;n=C[r]||C[0];break;case"ArrowLeft":var o=C.indexOf(e.currentTarget)-1;n=C[o]||C[C.length-1]}null==(t=n)||t.focus()};return o.createElement("div",{className:"tabs-container"},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,u.Z)("tabs",{"tabs--block":i},f)},h.map((function(e){var t=e.value,n=e.label;return o.createElement("li",{role:"tab",tabIndex:O===t?0:-1,"aria-selected":O===t,className:(0,u.Z)("tabs__item",c,{"tabs__item--active":O===t}),key:t,ref:function(e){return C.push(e)},onKeyDown:q,onFocus:T,onClick:T},null!=n?n:t)}))),a?(0,o.cloneElement)(m.filter((function(e){return e.props.value===O}))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},m.map((function(e,t){return(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==O})}))))}function p(e){var t=(0,a.Z)();return o.createElement(d,(0,r.Z)({key:String(t)},e))}},5541:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>u,toc:()=>c});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),i=(n(6396),n(8215),["components"]),l={title:"v0.15.x to v0.16.x"},s=void 0,u={unversionedId:"migration-guides/v0.15.x-to-v0.16.x",id:"migration-guides/v0.15.x-to-v0.16.x",title:"v0.15.x to v0.16.x",description:"Filter on Relations",source:"@site/docs/migration-guides/v0.15.x-to-v0.16.x.mdx",sourceDirName:"migration-guides",slug:"/migration-guides/v0.15.x-to-v0.16.x",permalink:"/nestjs-query/docs/migration-guides/v0.15.x-to-v0.16.x",editUrl:"https://github.com/tripss/nestjs-query/edit/master/documentation/docs/migration-guides/v0.15.x-to-v0.16.x.mdx",tags:[],version:"current",frontMatter:{title:"v0.15.x to v0.16.x"},sidebar:"docs",previous:{title:"v0.22.x to v0.23.x",permalink:"/nestjs-query/docs/migration-guides/v0.22.x-to-v0.23.x"},next:{title:"v0.14.x to v0.15.x",permalink:"/nestjs-query/docs/migration-guides/v0.14.x-to-v0.15.x"}},c=[{value:"Filter on Relations",id:"filter-on-relations",children:[],level:2},{value:"Filter Definitions",id:"filter-definitions",children:[],level:2}],d={toc:c};function p(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"filter-on-relations"},"Filter on Relations"),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"v0.16.x")," we made a big step forward in the functionality of relations by allowing for filtering on their properties. While making this change it was aso decided to unify the way that relations are defined."),(0,a.kt)("p",null,"In previous versions of ",(0,a.kt)("inlineCode",{parentName:"p"},"nestjs-query")," you could define relations using the ",(0,a.kt)("inlineCode",{parentName:"p"},"@Relation")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"@Connection")," decorator as well as manually defining them when creating your resolvers, this leads to an in consistent experience while using ",(0,a.kt)("inlineCode",{parentName:"p"},"nestjs-query"),". In the latest version all relations ",(0,a.kt)("strong",{parentName:"p"},"MUST")," be defined using the decorators."),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"v0.16.x")," there are two new decorators (",(0,a.kt)("inlineCode",{parentName:"p"},"@FilterableRelation"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"@FilterableConnection"),") exposed to allow you to decide if end users should be able to filter on the relation."),(0,a.kt)("p",null,"To read more about the new decorators as well as defining relations you can read the ",(0,a.kt)("a",{parentName:"p",href:"/nestjs-query/docs/graphql/relations"},(0,a.kt)("inlineCode",{parentName:"a"},"relations docs"))),(0,a.kt)("h2",{id:"filter-definitions"},"Filter Definitions"),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"v0.16.x")," filters are defined based on the operation (read, update, delete). In previous versions of ",(0,a.kt)("inlineCode",{parentName:"p"},"nestjs-query")," all filters for a type in graphql were the same. In ",(0,a.kt)("inlineCode",{parentName:"p"},"v0.16.x")," this behavior needed to change in order to support filtering on relations."),(0,a.kt)("p",null,"This should be a passive change for most, however the generated graphql schema will contain new types for each filter operation."))}p.isMDXComponent=!0}}]);